<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Activity 生命周期]]></title>
      <url>%2F2016%2F10%2F10%2FActvitiy%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Activity 生命周期 在Android 生命周期中有很多种状态，我们可以在多种状态中切换，来控制自己的生命周期。但是在这些状态中只有三种是稳定的，而其他的状态都是过渡的不会存在很久。 Resumed/Running:该状态下，Activity处于Activity栈顶部，用户可以与它进行交互。 Paused：该状态下，Activity被另外一个非全屏或者半通明的Activity遮盖，并压入Activity堆栈， 就进入了Paused状态，不能与用户交互，但是所有的状态信息，成员变量都保留，只有在系统内存 极低的情况下才会被回收。 Stopped：该状态下，Activity被另外一个Activity完全覆盖，就进入Stopped状态，这时它不可见，但是依然保持着所有的状态信息和成员变量。 Actvitiy 生命周期图 启动与销毁Activity的过程 在系统调用onCreate(),马上调用onStart(),之后再执行onResume()，停留在Resumed状态，完成启动。系统调用onDestroy()销毁Activity。 onCreate()：声明UI元素，定义成员变量，配置UI等（onCreate里面尽量少做事情，避免程序启动太久都看不到界面）。 onDestory()：进行资源清理，杀死后台线程。 暂停与恢复Activity的过程 当Activity被其他组件阻塞时部分不可见，就会导致当前Activity进入Pause状态，系统就会调用activity中的onPause()方法。当阻塞结束后，就会调用onResume()方法恢复到Resumed状态。 onPause()：释放系统资源（如broadcast receivers, sensors等）、停止动画或者是其他正在运行的操作。 onResume()：重新初始化那些在 onPause()中释放的资源，并执行一些停止的操作（如开启动画）。 停止与重启Activity的过程 当Activity部分不可见时，有2种可能，从部分不可见到可见，系统调用onResume()恢复到Resumed状态；从部分不可见到完全不可见，系统调用onStop()停止Activity进入Stopped状态，注意无论什么原因导致Activity停止，系统总是会在onStop()之前调用onPause()方法。系统调用onRestart()，马上调用onStart()，之后再执行onResume()。 onStop()：释放系统资源、执行那些CPU intensive的shut-down操作，例如往数据库写信息。 onStart()：重新初始化那些在 onStop()中释放的资源。 重新创建Activity 当系统开始停止Activity时，只有在Activity实例会需要重新创建的情况下才会调用到onSaveInstanceState() (1) ，在这个方法里面可以指定额外的状态数据到Bunde中。如果这个Activity被destroyed然后这个实例又需要被重新创建时，系统会传递在 (1) 中的状态数据到 onCreate() (2) 与 onRestoreInstanceState()(3). 通常来说用户点击Back按钮或者是activity通过调用finish()结束自己时，系统就丢失了对Activity实例的引用，不会调用onSaveInstanceState()。如果是因为系统资源紧张或者跳转到其他的activity或者是点击Home而导致Activity的Destory，就会调用onSaveInstanceState() 方法。 要恢复状态信息调用onRestoreInstanceState()方法。 参考(http://hukai.me/android-training-course-in-chinese/basics/activity-lifecycle/index.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 导航栏和状态栏操作]]></title>
      <url>%2F2016%2F04%2F12%2FAndroid%20%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%92%8C%E7%8A%B6%E6%80%81%E6%A0%8F%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[淡化状态栏和系统栏 在版本为4.0以上的Android系统上,可以使用 SYSTEM_UI_FLAG_LOW_PROFILE 这个标签 decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE); 显示状态栏与导航栏 decorView.setSystemUiVisibility(0); 隐藏状态栏 在4.0及以下版本中隐藏状态栏有2种方法 在你的manifest文件中设置Activity的主题123&lt;application android:theme=&quot;@android:style/Theme.Holo.NoActionBar.Fullscreen&quot; &gt;&lt;/application&gt; 设置主题的优势是:易于维护，且不像动态设置标签那样容易出错。有更流畅的UI转换，因为在初始化你的Activity之前,系统已经得到了需要渲染UI的信息。 使用WindowManager来动态隐藏状态栏1234567891011public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &lt; 16) &#123; getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); &#125; setContentView(R.layout.activity_main); &#125;&#125; 在4.1及以上版本中隐藏状态栏。使用 setSystemUiVisibility() 进行动态隐藏 12345View decorView = getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);ActionBar actionBar = getActionBar();actionBar.hide(); 让内容显示在状态栏之后。 使用 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 标签并在xml 中使用android:fitsSystemWindows=”true”,它会调整父ViewGroup使它留出特定区域给系统栏,确保应用中特定区域不会被系统栏掩盖。 隐藏导航栏 在4.0及以上版本中隐藏导航栏 1234View decorView = getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions); 让内容显示在导航栏之后 使用 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 标签 要注意的几点: 一旦UI标签被清除就必须重新设置(比如跳到另外一个Activity)。 在不同地方监听UI标签是有所不同的,比如在Activity的onCreate()方法中隐藏状态 栏,当用户按下home键系统栏就会重新显示,如果你想让在不同Activity之间切换,系统UI保持不变，你需要在onResume()与onWindowFocusChaned()里设定UI标签。 setSystemUiVisibility()仅仅在被调用的View显示的时候才会生效。 当从View导航到别的地方时，用setSystemUiVisibility()设置的标签会被清除。 全屏沉浸式应用 使用非粘性沉浸模式 1234567mDecorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // 隐藏导航栏 | View.SYSTEM_UI_FLAG_FULLSCREEN // 隐藏状态栏 | View.SYSTEM_UI_FLAG_IMMERSIVE); 使用粘性沉浸模式 1234567decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY); 注意沉浸式只能在android 4.4以上的系统使用 响应UI可见性的变化123456789101112decorView.setOnSystemUiVisibilityChangeListener (new View.OnSystemUiVisibilityChangeListener() &#123; @Override public void onSystemUiVisibilityChange(int visibility) &#123; //全屏 if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) &#123; &#125; else &#123; &#125; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 半通明状态栏]]></title>
      <url>%2F2016%2F04%2F08%2FAndroid%20%E5%8D%8A%E9%80%9A%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%2F</url>
      <content type="text"><![CDATA[Android 从4.4 版本开始支持半透明状态栏效果。4.4设置方式与5.0不同(5.0推出了Material Design,不用设置默认就有)。在4.4 设置半通明状态栏效果,有2种方法。 第一种方案 在代码中设置透明化 1234if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);&#125; 使布局扩展至系统状态栏,状态栏会覆盖在toolbar上。 在根布局中添加android:paddingTop=&quot;@dimen/toolbar_padding_top&quot;在values中的dimens文件里设为0dp,在values-v19的styles里设为25dp。 第二种方案 在代码中设置透明化12345678if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS| localLayoutParams.flags); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; //设置边距 view(根布局).setFitsSystemWindows(true); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Paint 属性详解]]></title>
      <url>%2F2016%2F01%2F19%2FAndroid%20Paint%20%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Paint即画笔,在绘图过程中起到了极其重要的作用,画笔主要保存了颜色， 样式等绘制信息,指定了如何绘制文本和图形,画笔对象有很多设置方法， 大体上可以分为两类,一类与图形绘制相关,一类与文本绘制相关. 图形绘制 设置Paint的标志Paint.ANTI_ALIAS_FLAG 抗锯齿, Paint.FILTER_BITMAP_FLAG 位图过滤器,Paint.DITHER_FLAG 防抖动, Paint.UNDERLINE_TEXT_FLAG 启用下划线,Paint.STRIKE_THRU_TEXT_FLAG 启用中划线, Paint.FAKE_BOLD_TEXT_FLAG 加粗文本Paint.LINEAR_TEXT_FLAG 线性文本, Paint.SUBPIXEL_TEXT_FLAG 应用子像素抗锯齿效果Paint.DEV_KERN_TEXT_FLAG 使用设备的文本字距。 设置绘制的颜色 a代表透明度，r，g，b代表颜色值。setARGB(int a,int r,int g,int b); 设置a[0..255] 0：代表全透明 255代表不透明。setAlpha(int a); 设置绘制的颜色,使用颜色值来表示,该颜色值包括透明度和RGB颜色。setColor(int color) 设置是否使用抗锯齿功能,会消耗较大资源,绘制图形速度会变慢。setAntiAlias(boolean aa); 设置是否使用图像抖动处理,会使绘制出来的图片颜色更加平滑和饱满,图像更加清晰。setDither(boolean dither); 设置画笔的隐藏模式,INTING_OFF 或者 HINTING_ON。setHinting(int mode) 如果该项设置为true,则图像在动画进行中会滤掉对Bitmap图像 的优化操作,加快显示速度,本设置项依赖于dither和xfermode的设置setFilterBitmap(boolean filter); 设置MaskFilter,可以用不同的MaskFilter实现滤镜的效果,如滤化,立体等。setMaskFilter(MaskFilter maskfilter); 设置颜色过滤器,可以在绘制颜色时实现不用颜色的变换效果。setColorFilter(ColorFilter colorfilter); 设置绘制路径的效果,如点画线等。setPathEffect(PathEffect effect); 设置图像效果,使用Shader可以绘制出各种渐变效果。setShader(Shader shader); 在图形下面设置阴影层,产生阴影效果,radius为阴影的角度,dx和dy为阴影在x轴和y轴上的距离, color为阴影的颜色。setShadowLayer(float radius ,float dx,float dy,int color); 设置画笔的样式,为FILL 描边,FILL_OR_STROKE 描边并填充,或STROKE 填充。setStyle(Paint.Style style); 设置画笔的笔触风格，如圆形样式Cap.ROUND,或方形样式Cap.SQUARE,默认是Paint.Cap.BUTT,也是方形样式。setStrokeCap(Paint.Cap cap); 设置接合处的形态，如Join.MITER 锐角,Join.ROUND 圆弧,Join.BEVEL 直线。setStrokeJoin(Paint.Join join); 设置笔画的倾斜度,取值：&gt;=0,设置笔触的连接处的样式,可以和setStrokeJoin()来比较。setStrokeMiter(float miter ) 设置画笔的粗细度。setStrokeWidth(float width); 文本绘制 模拟实现粗体文字，设置在小字体上效果会非常差。‘setXfermode(Xfermode xfermode);’ 设置该项为true，将有助于文本在LCD屏幕上的显示效果。setSubpixelText(boolean subpixelText); 设置绘制文字的对齐方向。setTextAlign(Paint.Align align); 设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果 。setTextScaleX(float scaleX); 设置绘制文字的字号大小,设置值必须大于0。setTextSize(float textSize); 设置斜体文字，skewX为倾斜弧度,值为右负左正,官方推崇的值为-0.25。setTextSkewX(float skewX); 设置Typeface对象,即字体风格,包括粗体,斜体以及衬线体,非衬线体等。setTypeface(Typeface typeface); 设置带有下划线的文字效果。setUnderlineText(boolean underlineText); 设置带有删除线的效果。setStrikeThruText(boolean strikeThruText); 设置是否打开线性文本标识。setLinearText (boolean linearText) 设置地理位置,直接传入Locale.getDefault()。setTextLocale (Locale locale) 设置字体的样式,样式可以为null。setFontFeatureSettings(String settings)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Task 相关]]></title>
      <url>%2F2015%2F11%2F29%2FActivity%20Task%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[Android 任务栈简介 在Android 系统中，通过栈结构来保存整个APP的Activity，栈的结构是先进先出的线性表，当一个Activity启动另外一个Activity的时候，新启动的Activity就会置于任务栈的顶端，并处于活动状态,而启动它的Activity依然保持在任务栈中，处于停止状态，当用户按下返回键或者调用Finish方法时，系统会移除顶部的Activity，让后面的Activity回复活动状态。当然，这里也有特权阶级，就是在AndroidManinifest文件中的属性android：launchMode来设置或者通过Intent的flag来设置。 AndroidMainifest启动模式 Android 的启动模式一个有四种，分别是standard、singleTop、singleTask、singleStance，具有不同的功能。 standard默认启动模式，每次激活Activity都会创建新的实例，并放入任务栈中。使用场景：大多数的Activity。 singleTop如果在任务的栈顶正好存在该Activity的实例，就重用该实例(会调用实例的onNewIntent())，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景：接受消息后显示的界面（新闻类和阅读类App的内容界面），比如 singleTask如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景：浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleStance在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景：如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。 注意：如果在一个singleTask和singleStance的ActivityA中通过startActivityResult()方法启动另外一个ActivityB，那么系统会直接方法Activity.RESULT_CANCELED而不会再去等待方法。这是游戏系统在Framework层做了限制，所以二种不同Task之间，默认是不能传递数据的，如果一定要传递，那就只能通过Intent来绑定数据。 Intent Flag 启动模式 Intent.FLAG_ACTIVITY_NEW_TASK（默认） 使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task，该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。 Intent.FLAG_ACTIVITY_SINGLE_TOP 使用singletop模式来启动一个Activity，与指定android：launchMode=”singleTop“效果相同。 Intent.FLAG_ACTIVITY_CLEAR_TOP 如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的I ntent投递到老的Activity（现在位于顶端）中。例如：假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。 Intent.FLAG_ACTIVITY_NO_HISTORY 如果设置，这将在Task的Activitystack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED在重置Task或者启动Activity创建新的Task时生效。 Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 使用这种模式启动Activity，重置该Task时清除该Activity。例如：A以这种模式启动B，B又启动C，当用户离开应用，一段时间后又从Home回到应用，显示A界面，当前Activity栈为A。 Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。例如：假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 如果设置，新的Activity不会在最近启动的Activity的列表中保存。 Intent.FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。 清空任务栈 系统提供清空任务栈的方法让我让我们将一个Task清除。通常情况下，我们在AndroidMainifest文件中的标签中使用以下几种属性来清理任务栈。 clearTaskOnLaunch 每次返回该Activity时，都将该Activity之上的所有Activity清除，通过这个属性，可以让这个Task每次在初始化的时候，都只 有这个Activity。 finishOnTaskLaunch finishOnTaskLaunch属性与clearTaskOnLaunch类似，只不过finishOnTaskLaunch是作业在自己身上，通过这个属性，当离开这个Activity所在的Task，那么用户返回时，该Activity就会被finish掉。 alwaysRetainTaskState alwayRetainTaskState属性给Task设置免死金牌，如果如果将Activity的这个属性设置为True，那么该Activity所在的Task将不接受任何清理命令，一直保持当前Task状态。 allowTaskReparenting Activity实例在当前应用退居后台后，是否能从启动它的那个task移动到有共同affinity的task，“true”表示可以移动，“false”表示它必须呆在当前应用的task中，默认值为false。 参考(http://blog.csdn.net/liuhe688/article/details/6761337)(https://my.oschina.net/u/2336511/blog/392412)]]></content>
    </entry>

    
  
  
</search>
