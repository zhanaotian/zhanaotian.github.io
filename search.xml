<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[总数操作符]]></title>
      <url>%2F2016%2F11%2F15%2F%E6%80%BB%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[总数操作符any如果至少有一个元素符合给出的判断条件，则返回true。 123val list = listOf(1, 2, 3, 4, 5, 6)assertTrue(list.any &#123; it % 2 == 0 &#125;)assertFalse(list.any &#123; it &gt; 10 &#125;) all如果全部的元素符合给出的判断条件，则返回true。 12assertTrue(list.all &#123; it &lt; 10 &#125;)assertFalse(list.all &#123; it % 2 == 0 &#125;) count返回符合给出判断条件的元素总数。 1assertEquals(3, list.count &#123; it % 2 == 0 &#125;) fold在一个初始值的基础上从第一项到最后一项通过一个函数累计所有的元素。 1assertEquals(25, list.fold(4) &#123; total, next -&gt; total + next &#125;) foldRight与fold一样，但是顺序是从最后一项到第一项。 1assertEquals(25, list.foldRight(4) &#123; total, next -&gt; total + next &#125;) forEach遍历所有元素，并执行给定的操作。 1list.forEach &#123; println(it) &#125; forEachIndexed与forEach，但是我们同时可以得到元素的index。 12list.forEachIndexed &#123; index, value -&gt; println("position $index contains a $value") &#125; max返回最大的一项，如果没有则返回null。 1assertEquals(6, list.max()) maxBy根据给定的函数返回最大的一项，如果没有则返回null。 12// The element whose negative is greaterassertEquals(1, list.maxBy &#123; -it &#125;) min返回最小的一项，如果没有则返回null。 1assertEquals(1, list.min()) minBy根据给定的函数返回最小的一项，如果没有则返回null。 12// The element whose negative is smallerassertEquals(6, list.minBy &#123; -it &#125;) none如果没有任何元素与给定的函数匹配，则返回true。 12// No elements are divisible by 7assertTrue(list.none &#123; it % 7 == 0 &#125;) reduce与fold一样，但是没有一个初始值。通过一个函数从第一项到最后一项进行累计。 1assertEquals(21, list.reduce &#123; total, next -&gt; total + next &#125;) reduceRight与reduce一样，但是顺序是从最后一项到第一项。 1assertEquals(21, list.reduceRight &#123; total, next -&gt; total + next &#125;) sumBy返回所有每一项通过函数转换之后的数据的总和。 1assertEquals(3, list.sumBy &#123; it % 2 &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集合和函数操作符]]></title>
      <url>%2F2016%2F11%2F15%2F%E9%9B%86%E5%90%88%E5%92%8C%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[集合和函数操作符在我们这个项目我们已经使用过集合了，但是现在是时候展示它们结合函数操作符之后有多强大了。关于函数式编程很不错的一点是我们不用去解释我们怎么去做，而是直接说我想做什么。比如，如果我想去过滤一个list，不用去创建一个list，遍历这个list的每一项，然后如果满足一定的条件则放到一个新的集合中，而是直接食用filer函数并指明我想用的过滤器。用这种方式，我们可以节省大量的代码。 虽然我们可以直接用Java中的集合，但是Kotlin也提供了一些你希望用的本地的接口： Iterable：父类。所有我们可以遍历一系列的都是实现这个接口。 MutableIterable：一个支持遍历的同时可以执行删除的Iterables。 Collection：这个类相是一个范性集合。我们通过函数访问可以返回集合的size、是否为空、是否包含一个或者一些item。这个集合的所有方法提供查询，因为connections是不可修改的。 MutableCollection：一个支持增加和删除item的Collection。它提供了额外的函数，比如add 、remove、clear等等。 List：可能是最流行的集合类型。它是一个范性有序的集合。因为它的有序，我们可以使用get函数通过position来访问。 MutableList：一个支持增加和删除item的List。 Set：一个无序并不支持重复item的集合。 MutableSet：一个支持增加和删除item的Set。 Map：一个key-value对的collection。key在map中是唯一的，也就是说不能有两对key是一样的键值对存在于一个map中。 MutableMap：一个支持增加和删除item的map。 有很多不同集合可用的函数操作符。我想通过一个例子来展示给你看。知道有哪些可选的操作符是很有用的，因为这样会更容易分辨它们使用的时机。 总数操作符 过滤操作符 映射操作符 元素操作符 生产操作符 顺序操作符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[委托]]></title>
      <url>%2F2016%2F11%2F15%2F%E5%A7%94%E6%89%98%2F</url>
      <content type="text"><![CDATA[委托委托属性我们可能需要一个属性具有一些相同的行为，使用lazy或者observable可以被很有趣地实现重用。而不是一次又一次地去声明那些相同的代码，Kotlin提供了一个委托属性到一个类的方法。这就是我们知道的委托属性。 当我们使用属性的get或者set的时候，属性委托的getValue和setValue就会被调用。 属性委托的结构如下： 123456789class Delegate&lt;T&gt; : ReadWriteProperty&lt;Any?, T&gt; &#123; fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return ... &#125; fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; ... &#125;&#125; 这个T是委托属性的类型。getValue函数接收一个类的引用和一个属性的元数据。setValue函数又接收了一个被设置的值。如果这个属性是不可修改（val），就会只有一个getValue函数。 下面展示属性委托是怎么设置的： 123class Example &#123; var p: String by Delegate()&#125; 它使用了by这个关键字来指定一个委托对象。 标准委托在Kotlin的标准库中有一系列的标准委托。它们包括了大部分有用的委托，但是我们也可以创建我们自己的委托。 Lazy它包含一个lambda，当第一次执行getValue的时候这个lambda会被调用，所以这个属性可以被延迟初始化。之后的调用都只会返回同一个值。这是非常有趣的特性， 当我们在它们第一次真正调用之前不是必须需要它们的时候。我们可以节省内存，在这些属性真正需要前不进行初始化。 12345678910class App : Application() &#123; val database: SQLiteOpenHelper by lazy &#123; MyDatabaseHelper(applicationContext) &#125; override fun onCreate() &#123; super.onCreate() val db = database.writableDatabase &#125;&#125; 在这个例子中，database并没有被真正初始化，直到第一次调用onCreate时。在那之后，我们才确保applicationContext存在，并且已经准备好可以被使用了。lazy操作符是线程安全的。 如果你不担心多线程问题或者想提高更多的性能，你也可以使用lazy(LazyThreadSafeMode.NONE){ ... }。 Observable这个委托会帮我们监测我们希望观察的属性的变化。当被观察属性的set方法被调用的时候，它就会自动执行我们指定的lambda表达式。所以一旦该属性被赋了新的值，我们就会接收到被委托的属性、旧值和新值。 123456class ViewModel(val db: MyDatabase) &#123; var myProperty by Delegates.observable("") &#123; d, old, new -&gt; db.saveChanges(this, new) &#125;&#125; 这个例子展示了，一些我们需要关心的ViewMode，每次值被修改了，就会保存它们到数据库。 Vetoable这是一个特殊的observable，它让你决定是否这个值需要被保存。它可以被用于在真正保存之前进行一些条件判断。 1234var positiveNumber = Delegates.vetoable(0) &#123; d, old, new -&gt; new &gt;= 0&#125; 上面这个委托只允许在新的值是正数的时候执行保存。在lambda中，最后一行表示返回值。你不需要使用return关键字（实质上不能被编译）。 Not Null有时候我们需要在某些地方初始化这个属性，但是我们不能在构造函数中确定，或者我们不能在构造函数中做任何事情。第二种情况在Android中很常见：在Activity、fragment、service、receivers……无论如何，一个非抽象的属性在构造函数执行完之前需要被赋值。为了给这些属性赋值，我们无法让它一直等待到我们希望给它赋值的时候。我们至少有两种选择方案。 第一种就是使用可null类型并且赋值为null，直到我们有了真正想赋的值。但是我们就需要在每个地方不管是否是null都要去检查。如果我们确定这个属性在任何我们使用的时候都不会是null，这可能会使得我们要编写一些必要的代码了。 第二种选择是使用notNull委托。它会含有一个可null的变量并会在我们设置这个属性的时候分配一个真实的值。如果这个值在被获取之前没有被分配，它就会抛出一个异常。 这个在单例App这个例子中很有用： 12345678910class App : Application() &#123; companion object &#123; var instance: App by Delegates.notNull() &#125; override fun onCreate() &#123; super.onCreate() instance = this &#125;&#125; 从Map中映射值另外一种属性委托方式就是，属性的值会从一个map中获取value，属性的名字对应这个map中的key。这个委托可以让我们做一些很强大的事情，因为我们可以很简单地从一个动态地map中创建一个对象实例。如果我们import kotlin.properties.getValue，我们可以从构造函数映射到val属性来得到一个不可修改的map。如果我们想去修改map和属性，我们也可以import kotlin.properties.setValue。类需要一个MutableMap作为构造函数的参数。 想象我们从一个Json中加载了一个配置类，然后分配它们的key和value到一个map中。我们可以仅仅通过传入一个map的构造函数来创建一个实例： 12345678import kotlin.properties.getValueclass Configuration(map: Map&lt;String, Any?&gt;) &#123; val width: Int by map val height: Int by map val dp: Int by map val deviceName: String by map&#125; 作为一个参考，这里我展示下对于这个类怎么去创建一个必须要的map： 123456conf = Configuration(mapOf( "width" to 1080, "height" to 720, "dp" to 240, "deviceName" to "mydevice")) 自定义的委托先来说说我们要实现什么，举个例子，我们创建一个notNull的委托，它只能被赋值一次，如果第二次赋值，它就会抛异常。 Kotlin库提供了几个接口，我们自己的委托必须要实现：ReadOnlyProperty和ReadWriteProperty。具体取决于我们被委托的对象是val还是var。 我们要做的第一件事就是创建一个类然后继承ReadWriteProperty： 123456789private class NotNullSingleValueVar&lt;T&gt;() : ReadWriteProperty&lt;Any?, T&gt; &#123; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; throw UnsupportedOperationException() &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; &#125;&#125; 这个委托可以作用在任何非null的类型。它接收任何类型的引用，然后像getter和setter那样使用T。现在我们需要去实现这些函数。 Getter函数 如果已经被初始化，则会返回一个值，否则会抛异常。 Setter函数 如果仍然是null，则赋值，否则会抛异常。 123456789101112private class NotNullSingleValueVar&lt;T&gt;() : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value: T? = null override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value ?: throw IllegalStateException("$&#123;desc.name&#125; " + "not initialized") &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; this.value = if (this.value == null) value else throw IllegalStateException("$&#123;desc.name&#125; already initialized") &#125;&#125; 现在你可以创建一个对象，然后添加函数使用你的委托： 1234object DelegatesExt &#123; fun notNullSingleValue&lt;T&gt;(): ReadWriteProperty&lt;Any?, T&gt; = NotNullSingleValueVar()&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作符表]]></title>
      <url>%2F2016%2F11%2F15%2F%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[操作符表这里你可以看见一系列包括操作符和对应方法的表。对应方法必须在指定的类中通过各种可能性被实现。 一元操作符 操作符 函数 +a a.unaryPlus() -a a.unaryMinus() !a a.not() a++ a.inc() a– a.dec() 二元操作符 操作符 函数 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.mod(b) a..b a.rangeTo(b) a in b a.contains(b) a !in b !a.contains(b) a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.modAssign(b) 数组操作符 操作符 函数 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 等于操作符 操作符 函数 a == b a?.equals(b) ?: b === null a != b !(a?.equals(b) ?: b === null) 相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称。方法必须要如下准确地被实现： 1operator fun equals(other: Any?): Boolean 操作符===和!==用来做身份检查（它们分别是Java中的==和!=），并且它们不能被重载。 函数调用 方法 调用 a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, …, i_n) a.invoke(i_1, …, i_n)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[扩展函数]]></title>
      <url>%2F2016%2F11%2F15%2F%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[扩展函数扩展函数数是指在一个类上增加一种新的行为，甚至我们没有这个类代码的访问权限。这是一个在缺少有用函数的类上扩展的方法。在Java中，通常会实现很多带有static方法的工具类。Kotlin中扩展函数的一个优势是我们不需要在调用方法的时候把整个对象当作参数传入。扩展函数表现得就像是属于这个类的一样，而且我们可以使用this关键字和调用所有public方法。 举个例子，我们可以创建一个toast函数，这个函数不需要传入任何context，它可以被任何Context或者它的子类调用，比如Activity或者Service： 123fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123; Toast.makeText(this, message, duration).show()&#125; 这个方法可以在Activity内部直接调用： 12toast("Hello world!")toast("Hello world!", Toast.LENGTH_LONG) 当然，Anko已经包括了自己的toast扩展函数，跟上面这个很相似。Anko提供了一些针对CharSequence和resource的函数，还有两个不同的toast和longToast方法： 12toast("Hello world!")longToast(R.id.hello_world) 扩展函数也可以是一个属性。所以我们可以通过相似的方法来扩展属性。下面的例子展示了使用他自己的getter/setter生成一个属性的方式。Kotlin由于互操作性的特性已经提供了这个属性，但理解扩展属性背后的思想是一个很不错的练习： 123public var TextView.text: CharSequence get() = getText() set(v) = setText(v) 扩展函数并不是真正地修改了原来的类，它是以静态导入的方式来实现的。扩展函数可以被声明在任何文件中，因此有个通用的实践是把一系列有关的函数放在一个新建的文件里。 这是Anko功能背后的魔法。现在通过以上，你也可以自己创建你的魔法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin 准备工作]]></title>
      <url>%2F2016%2F11%2F15%2FKotlin%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[Kotlin 准备工作在Android Studio 中安装 Kotlin 插件和Kotlin Android Extensions 插件 Kotlin：这是一个基础的插件。它能让Android Studio懂得Kotlin代码。它会每次在新的Kotlin语言版本发布的时候发布新的插件版本，这样我们可以通过它发现新版本特性和弃用的警告。这是你要使用Kotlin编写Android应用唯一的插件。 Kotlin Android Extensions：Kotlin团队还为Android开发发布了另外一个有趣的插件。这个Android Extensions可以让你自动地从XML中注入所有的View到Activity中，举个例子，你不需要使用findViewById()。你将会立即得到一个从属性转换过来的view。你将需要安装这个插件来使用这个特性。 配置GradleTools –&gt; Kotlin –&gt; configure Kotlin Plugin Updates 转换成Kotlin 代码shift + commend + A 然后选择Code -&gt; Convert Java File to Kotlin File]]></content>
    </entry>

    
  
  
</search>
