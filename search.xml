<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android 启动Java8的lambad表达式]]></title>
      <url>%2F2016%2F05%2F20%2FAndroid%20%E5%90%AF%E7%94%A8Java8%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[添加到project的build.gradle中。1234567891011121314151617buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &apos;me.tatarka:gradle-retrolambda:3.6.0&apos; &#125;&#125;// Required because retrolambda is on maven centralrepositories &#123; mavenCentral()&#125;apply plugin: &apos;com.android.application&apos; //or apply plugin: &apos;java&apos;apply plugin: &apos;me.tatarka.retrolambda&apos; 设置java版本。在build.gradle的android节点下添加：1234567android &#123; compileOptions &#123; //设置java版本 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 对项目进行build。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FragmentManager Api 重要方法]]></title>
      <url>%2F2016%2F04%2F27%2F%E4%BA%86%E8%A7%A3%20FragmentManager%2F</url>
      <content type="text"><![CDATA[FragmentManager Api 重要方法： 方法 描述 addOnBackStackChangedListener 添加一个新的侦听器，监听Fragment栈的添加情况 beginTransaction() 创建一个新的事务来在运行时更改Fragment findFragmentById(int id) 通过id 从Activity的XML布局中查找Fragment实例 findFragmentByTag(String tag) 通过Tag 查找Fragment实例 popBackStack() 从Fragment栈中删除一个Fragment实例 popBackStackImmediate() 立即从Fragment栈中删除一个Fragment实例 executePendingTransactions() 强制立即执行提交 getBackStackEntryAt(int index) 根据坐标从Fragment栈返回对应的实例 getBackStackEntryCount() 返回当前Fragment栈里Fragment实例的数量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment 详解（三）]]></title>
      <url>%2F2016%2F04%2F27%2FFragment%20%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Fragment的startActivityForResult Fragment的startActivityForResult和Activity的startActivityForResult类似，只不过fragment没有setResult方法，所以只能使用父activity的setResult方法。 水果列表页123456789101112131415161718192021222324252627282930313233343536373839public class FruitsListFragment extends ListFragment &#123; public static final int REQUEST_CODE=0x110; public static final String REQUEST_DETAIL=&quot;request_detail&quot;; private ArrayAdapter&lt;String&gt; mAdapter; private int mPostion; private List&lt;String&gt; mList = Arrays.asList(&quot;苹果&quot;, &quot;香蕉&quot;, &quot;玻璃&quot;, &quot;梨子&quot;, &quot;西瓜&quot;, &quot;橙子&quot;); public FruitsListFragment() &#123; // Required empty public constructor &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; mPostion = position; Intent intent = new Intent(getActivity(), FruitsDetailsActivity.class); intent.putExtra(REQUEST_DETAIL, mList.get(position)); //跳转 startActivityForResult(intent, REQUEST_CODE); &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); mAdapter = new ArrayAdapter&lt;&gt;(getActivity(), android.R.layout.simple_list_item_1, mList); //设置适配器 setListAdapter(mAdapter); &#125; @Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; //修改数据 if (requestCode==REQUEST_CODE) &#123; mList.set(mPostion,data.getStringExtra(REQUEST_DETAIL)); mAdapter.notifyDataSetChanged(); &#125; &#125;&#125; 详情页12345678910111213141516171819202122232425262728293031323334353637383940414243public class FruitsDetailsFragment extends Fragment &#123; private static final String ARG_PARAM1 = &quot;param1&quot;; private String mParam1; public FruitsDetailsFragment() &#123; &#125; public static FruitsDetailsFragment newInstance(String param1) &#123; FruitsDetailsFragment fragment = new FruitsDetailsFragment(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); fragment.setArguments(args); return fragment; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view=inflater.inflate(R.layout.fragment_fragment_fruits_details, container, false); final EditText editText= (EditText) view.findViewById(R.id.fruits_details_ed); editText.setText(mParam1); view.findViewById(R.id.updateBtn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.putExtra(REQUEST_DETAIL, editText.getText().toString()); getActivity().setResult(110, intent); getActivity().finish(); &#125; &#125;); return view; &#125;&#125; 嵌套Fragment123456789101112131415161718192021222324public class ParentFragment extends Fragment &#123; public ParentFragment() &#123; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_parent, container, false); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; Fragment childFragment = new ChildFragment(); FragmentTransaction transaction = getChildFragmentManager().beginTransaction(); transaction.replace(R.id.child_fragment_container, childFragment).commit(); &#125; public static class ChildFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_child, container, false); &#125; &#125;&#125; fragment_parent.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:gravity=&quot;center&quot; android:textSize=&quot;26sp&quot; android:background=&quot;@color/colorAccent&quot; android:text=&quot;I am the parent fragment&quot; /&gt; &lt;FrameLayout android:id=&quot;@+id/child_fragment_container&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; fragment_child.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;ChildFragment&quot; android:textSize=&quot;26sp&quot; /&gt;&lt;/LinearLayout&gt; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment 详解（二）]]></title>
      <url>%2F2016%2F04%2F26%2FFragment%20%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Activity与Fragment通信 一个activity通常包含多个fragment，而fragment通常只能与其父activity通信，fragment把activity视为与其他fragment交互的桥梁。要记住的是fragment不应该互相沟通，而应该只通过其父activity进行沟通，因为fragment应该是模块化、独立、可重复使用的组件，fragment互相通信不符合低耦合，高内聚的设计。 fragment与activity通信有三种方法： Bundle activity构造一个fragment并设置参数 方法 activity可以调用fragment实例上面的方法 Listener fragment可以通过界面触发activity中的侦听事件 Fragment with Arguments 修改刚刚的LifecycleFragment，创建一个使用newInstance参数创建fragment的静态方法，并设置参数。1234567891011public class FooFragment extends Fragment &#123; private static final String ARG_PARAM1 = &quot;param1&quot;; private String mParam1; public static FooFragment newInstance(String param1) &#123; FooFragment fragment = new FooFragment(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); fragment.setArguments(args); return fragment; &#125;&#125; 在onCreate访问参数，获取数据。1234567@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); &#125;&#125; 在DynamicAddActivity中动态加载fragment1234FragmentTransaction ft = getSupportFragmentManager().beginTransaction();FooFragment fragment = FooFragment.newInstance(&quot;fragment 生命周期&quot;);ft.replace(R.id.content, fragment);ft.commit(); Fragment Methods123456789public class FooFragment extends Fragment &#123; public void setParam(String param) &#123; textView.setText(param); &#125;&#125;if (fooFragment!=null&amp;&amp;fooFragment.isVisible()) &#123; fooFragment.setParam(link+1);&#125; Fragment Listener123456789101112131415161718192021222324252627282930313233343536public class FooFragment extends Fragment &#123; private OnItemSelectedListener listener; public interface OnItemSelectedListener &#123; public void onItemSelected(String link); &#125; @Override public void onAttach(Context context) &#123; super.onAttach(context); if (context instanceof OnItemSelectedListener) &#123; listener = (OnItemSelectedListener) context; &#125; else &#123; throw new ClassCastException(context.toString() + &quot; must implement MyListFragment.OnItemSelectedListener&quot;); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View view = inflater.inflate(R.layout.fragment_foo, container, false); textView = (TextView) view.findViewById(R.id.textView1); textView.setText(mParam1); view.findViewById(R.id.button1).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (listener != null) &#123; listener.onItemSelected(textView.getText().toString()); &#125; &#125; &#125;); return view; &#125;&#125; 在activity中实现OnItemSelectedListener监听器。12345678public class DynamicAddActivity extends AppCompatActivity implements FooFragment.OnItemSelectedListener&#123; @Override public void onItemSelected(String link) &#123; if (fooFragment!=null&amp;&amp;fooFragment.isVisible()) &#123; fooFragment.setParam(link+1); &#125; &#125;&#125; 给fragment添加导航菜单 在Fragment的onCreate加载菜单项。 12345@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setHasOptionsMenu(true);&#125; 通过onCreateOptionsMenu直接向Fragment添加菜单项。 1234@Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; inflater.inflate(R.menu.fragment_menu, menu); &#125; 通过onOptionsItemSelected管理Fragment的菜单项。 12345678910@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.edit_item: Toast.makeText(getActivity(), &quot;点击&quot;, Toast.LENGTH_SHORT).show(); return true; default: return super.onOptionsItemSelected(item); &#125;&#125; 查找Fragment实例 通常我们需要在Activity布局文件中查找Fragment实例，有3种查找现有Fragment实例的方法： ID -通过调用查找片段findFragmentById上FragmentManager Tag -通过调用查找片段findFragmentByTag上FragmentManager Pager -通过调用getRegisteredFragmenta 查找片段PagerAdapter 通过ID查找Fragment。12345678910111213141516171819public class SingleFragmentActivity extends AppCompatActivity &#123; public Fragment createFragment(); @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_content); //fragment管理器 FragmentManager fm = getSupportFragmentManager(); //根据id查找fragment实例 Fragment fragment = fm.findFragmentById(R.id.content); //通过判断savedInstanceState时候为空，登出activity时候重新创建 if (fragment == null) &#123; fragment = createFragment(); //添加 fm.beginTransaction().add(R.id.content, fragment).commit(); &#125; &#125;&#125; 通过Tag查找Fragment实例。12345678910111213141516public class SingleFragmentActivity extends AppCompatActivity &#123; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_content); //fragment管理器 FragmentManager fm = getSupportFragmentManager(); //根据id查找fragment实例 Fragment fragment = fm.findFragmentByTag(“lifecycle”); //通过判断savedInstanceState时候为空，登出activity时候重新创建 if (fragment == null) &#123; //添加 fm.beginTransaction().add(R.id.content, fragment).commit(); &#125; &#125;&#125; 如果你使用FragmentPagerAdapter可以通过getRegisteredFragment获取fragment实例。1adapterViewPager.getRegisteredFragment(0); 管理Fragment回退栈 fragment栈，和activity栈类似，我们可以通过activity维护一个回退栈来保存每次Fragment事务发生的变化。12345678final FragmentManager fm = getSupportFragmentManager(); //创建事务 FragmentTransaction fx = fm.beginTransaction(); if (oneFragment == null) &#123; oneFragment = new OneFragment(); fx.addToBackStack(&quot;one_Fragment&quot;); fx.add(R.id.fragmenttask_content, oneFragment, &quot;oneFragment&quot;).commit(); &#125; 从fragment栈弹出123if (fm.getBackStackEntryCount() &gt; 0) &#123; fm.popBackStack();&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment 详解（一）]]></title>
      <url>%2F2016%2F04%2F25%2FFragment%20%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Fragment 简介 Android 在 Android 3.0（API 级别 11）中引入了片段，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的UI设计提供支持。可以将多个Fragmen组合在一个Activity中来构建多窗格UI，以及在多个Activity中重复使用某个Fragment，可以将Fragment视为Activity的模块化组成部分。Fragment是必须嵌入Activity中，其生命周期直接受宿主 Activity 生命周期的影响，它不能独立于Activity运行。 定义 Fragment 在Android studio 新建FragmentDemo，然后新建一个FooFragment（右键-&gt;New-&gt;Fragment-&gt;Fragment(Blank)-&gt;FooFragment），不勾选inclue fragment fatoty methods ？、Inclue interface callback ？ FooFragment 代码如下：1234567891011public class FooFragment extends Fragment &#123; public FooFragment() &#123; // Required empty public constructor &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_foo, container, false); &#125; fragment_foo.xml 代码如下：12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt;&lt;/LinearLayout&gt; 向Activity 中嵌入Fragment有2种方式： 静态使用XML 动态使用Java代码 静态嵌入 新建一个Activity，命名为StateAddActivity，将fragment添加到StateAddActivity的xml布局文件中。 12345678public class StateAddActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_stateadd); &#125;&#125; activity_stateadd.xml1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;fragment android:name=&quot;com.jkwar.FragmentDemo.fragment.FooFragment&quot; android:id=&quot;@+id/fooFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; 动态嵌入 新建一个Activity，命名为DynamicAddActivity，通过FragmentManager类和FragmentTransaction类添加，删除和替换Fragment。 判断Fragment 状态的常用方法： 方法名 作用 isAdded() 如果fragment被添加到了activity中那么返回true，否则返回false isHidden() 如果fragment对象被隐藏那么返回true，否则返回false isRemoving() 如果fragment对象正在从父Activity中被删除那么返回true，否则返回false isResumed() 如果Fragment对象是在恢复状态中那么方法ture，否则返回false isVisible() 如果该Fragment对象对用户可见那么就返回true，否则返回false 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//fragment 管理器FragmentManager fm;FooFragment fooFragment;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dynamic_add); ButterKnife.bind(this); //初始化 fm = getSupportFragmentManager();&#125;public void onViewClicked(View view) &#123; //fragment事务 FragmentTransaction bt = fm.beginTransaction(); switch (view.getId()) &#123; case R.id.addBtn: if (fooFragment == null) &#123; fooFragment =new FooFragment(); bt.add(R.id.dynamic_content, fooFragment, &quot;fooFragment&quot;); &#125; else &#123; bt.replace(R.id.dynamic_content, fooFragment, &quot;fooFragment&quot;); &#125; break; case R.id.removeBtn: if (fooFragment != null &amp;&amp; fooFragment.isAdded()) &#123; bt.remove(fooFragment); &#125; break; case R.id.hideBtn: if (fooFragment != null &amp;&amp; fooFragment.isVisible()) &#123; bt.hide(fooFragment); &#125; break; case R.id.showBtn: if (fooFragment != null &amp;&amp; fooFragment.isHidden()) &#123; bt.show(fooFragment); &#125; break; case R.id.replaceBtn: FooFragment ff = FooFragment.newInstance(&quot;梨子&quot;); bt.replace(R.id.dynamic_content, ff, &quot;ff&quot;); break; &#125; //事务提交 bt.commit(); &#125; activity_dynamic_add.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:id=&quot;@+id/dynamic_content&quot; tools:context=&quot;com.jkwar.FragmentDemo.activity.DynamicAddActivity&quot;&gt; &lt;Button android:id=&quot;@+id/addBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;添加&quot; /&gt; &lt;Button android:id=&quot;@+id/removeBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;移除&quot; /&gt; &lt;Button android:id=&quot;@+id/hideBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;隐藏&quot; /&gt; &lt;Button android:id=&quot;@+id/showBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;显示&quot; /&gt; &lt;Button android:id=&quot;@+id/replaceBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;替换&quot; /&gt;&lt;/LinearLayout&gt; Fragment 的生命周期 Fragment所在的Activity的生命周期会影响Fragment的生命周期，表现为Activity的每次生命周期回调都会引发每个Fragment的类似回调，比如：当Activity收到onPause（）时，Activity的每个Fragment都会收到onPause（）。不过，fragment还有几个额外的生命周期，用于处理与Activity的交互，构造、销毁fragment UI等操作。这些回调方法是： onAttach（）：Fragment和Activity建立关联的时候调用。 onCreateView()：为Fragment加载布局时调用。 onActivityCreated()：当Activity中的onCreate方法执行完后调用。 onDestroyView()：Fragment中的布局被移除时调用。 onDetach()：Fragment和Activity解除关联的时候调用。 我们通过代码了解一下Fragment 生命周期：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class LifecycleFragment extends Fragment &#123; private final String TAG=LifecycleFragment.class.getSimpleName(); public LifecycleFragment() &#123; // Required empty public constructor &#125; //在Fragment已与Activity关联时调用 @Override public void onAttach(Context context) &#123; super.onAttach(context); Log.d(TAG, &quot;onAttach: &quot;); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, &quot;onCreate: &quot;); &#125; //为Fragment加载布局时调用 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.d(TAG, &quot;onCreateView: &quot;); return inflater.inflate(R.layout.fragment_lifecycle, container, false); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); Log.d(TAG, &quot;onViewCreated: &quot;); &#125; //当Activity中的onCreate方法执行完后调用 @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.d(TAG, &quot;onActivityCreated: &quot;); &#125; @Override public void onStart() &#123; super.onStart(); Log.d(TAG, &quot;onStart: &quot;); &#125; @Override public void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onResume: &quot;); &#125; @Override public void onPause() &#123; super.onPause(); Log.d(TAG, &quot;onPause: &quot;); &#125; //Fragment中的布局被移除时调用 @Override public void onDestroyView() &#123; super.onDestroyView(); Log.d(TAG, &quot;onDestroyView: &quot;); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, &quot;onDestroy: &quot;); &#125; //Fragment和Activity解除关联的时候调用 @Override public void onDetach() &#123; super.onDetach(); Log.d(TAG, &quot;onDetach: &quot;); &#125;&#125; 运行程序，打印日志如下： 点击Home键，打印日志如下： 重新进入重新，打印日志如下： 点击back键退出重新，打印日志如下： 源码下载 参考(http://blog.csdn.net/guolin_blog/article/details/8881711)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 导航栏和状态栏操作]]></title>
      <url>%2F2016%2F04%2F12%2FAndroid%20%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%92%8C%E7%8A%B6%E6%80%81%E6%A0%8F%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[淡化状态栏和系统栏 在版本为4.0以上的Android系统上,可以使用 SYSTEM_UI_FLAG_LOW_PROFILE 这个标签 decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE); 显示状态栏与导航栏 decorView.setSystemUiVisibility(0); 隐藏状态栏 在4.0及以下版本中隐藏状态栏有2种方法 在你的manifest文件中设置Activity的主题123&lt;application android:theme=&quot;@android:style/Theme.Holo.NoActionBar.Fullscreen&quot; &gt;&lt;/application&gt; 设置主题的优势是:易于维护，且不像动态设置标签那样容易出错。有更流畅的UI转换，因为在初始化你的Activity之前,系统已经得到了需要渲染UI的信息。 使用WindowManager来动态隐藏状态栏1234567891011public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &lt; 16) &#123; getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); &#125; setContentView(R.layout.activity_main); &#125;&#125; 在4.1及以上版本中隐藏状态栏。使用 setSystemUiVisibility() 进行动态隐藏 12345View decorView = getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);ActionBar actionBar = getActionBar();actionBar.hide(); 让内容显示在状态栏之后。 使用 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 标签并在xml 中使用android:fitsSystemWindows=”true”,它会调整父ViewGroup使它留出特定区域给系统栏,确保应用中特定区域不会被系统栏掩盖。 隐藏导航栏 在4.0及以上版本中隐藏导航栏 1234View decorView = getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions); 让内容显示在导航栏之后 使用 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 标签 要注意的几点: 一旦UI标签被清除就必须重新设置(比如跳到另外一个Activity)。 在不同地方监听UI标签是有所不同的,比如在Activity的onCreate()方法中隐藏状态 栏,当用户按下home键系统栏就会重新显示,如果你想让在不同Activity之间切换,系统UI保持不变，你需要在onResume()与onWindowFocusChaned()里设定UI标签。 setSystemUiVisibility()仅仅在被调用的View显示的时候才会生效。 当从View导航到别的地方时，用setSystemUiVisibility()设置的标签会被清除。 全屏沉浸式应用 使用非粘性沉浸模式 1234567mDecorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // 隐藏导航栏 | View.SYSTEM_UI_FLAG_FULLSCREEN // 隐藏状态栏 | View.SYSTEM_UI_FLAG_IMMERSIVE); 使用粘性沉浸模式 1234567decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY); 注意沉浸式只能在android 4.4以上的系统使用 响应UI可见性的变化123456789101112decorView.setOnSystemUiVisibilityChangeListener (new View.OnSystemUiVisibilityChangeListener() &#123; @Override public void onSystemUiVisibilityChange(int visibility) &#123; //全屏 if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) &#123; &#125; else &#123; &#125; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 半通明状态栏]]></title>
      <url>%2F2016%2F04%2F08%2FAndroid%20%E5%8D%8A%E9%80%9A%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%2F</url>
      <content type="text"><![CDATA[Android 从4.4 版本开始支持半透明状态栏效果。4.4设置方式与5.0不同(5.0推出了Material Design,不用设置默认就有)。在4.4 设置半通明状态栏效果,有2种方法。 第一种方案 在代码中设置透明化 1234if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);&#125; 使布局扩展至系统状态栏,状态栏会覆盖在toolbar上。 在根布局中添加android:paddingTop=&quot;@dimen/toolbar_padding_top&quot;在values中的dimens文件里设为0dp,在values-v19的styles里设为25dp。 第二种方案 在代码中设置透明化12345678if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS| localLayoutParams.flags); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; //设置边距 view(根布局).setFitsSystemWindows(true); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio Gradle 第三方依赖统一管理的几种方式]]></title>
      <url>%2F2016%2F04%2F06%2FAndroid%20Studio%20Gradle%E7%AC%AC%E4%B8%89%E4%BE%9D%E8%B5%96%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[第一种方式假设你的 Project 结构如下：1234567root --module1 --build.gradle --module2 --build.gradle ... --build.gradle ###使用脚本 config.gradle为了方便管理，可以在根目录下新建 config.gradle 文件12345678root --module1 --build.gradle --module2 --build.gradle ... --build.gradle --config.gradle 在 config.gradle 中添加如下代码（具体情况根据自己项目来定）：1234567891011121314151617181920212223242526ext &#123; kotlin_version = &apos;1.1.0&apos; android = [ compileSdkVersion: 25, buildToolsVersion: &quot;25.0.2&quot;, applicationId : &quot;com.jkwar.TomatoWork&quot;, minSdkVersion : 15, targetSdkVersion : 25, versionCode : 1, versionName : &quot;1.0&quot; ] dependencies = [ &quot;kotlin-stdlib&quot; : &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot;, &quot;appcompat-v7&quot; : &quot;com.android.support:appcompat-v7:25.3.1&quot;, &quot;constraint-layout&quot; : &quot;com.android.support.constraint:constraint-layout:1.0.2&quot;, &quot;rxjava&quot; : &quot;io.reactivex.rxjava2:rxjava:2.0.8&quot;, &quot;rxandroid&quot; : &quot;io.reactivex.rxjava2:rxandroid:2.0.1&quot;, &quot;retrofit&quot; : &quot;com.squareup.retrofit2:retrofit:2.2.0&quot;, &quot;gson&quot; : &quot;com.google.code.gson:gson:2.6.2&quot;, &quot;converter-gson&quot; : &quot;com.squareup.retrofit2:converter-gson:2.2.0&quot;, &quot;adapter-rxjava&quot; : &quot;com.squareup.retrofit2:adapter-rxjava2:2.2.0&quot;, &quot;logging-interceptor&quot; : &quot;com.squareup.okhttp3:logging-interceptor:3.6.0&quot; ]&#125; 在 root 目录下的build.gradle 中加上apply from: “config.gradle” 在需要添加依赖的 Module 中使用 android 节点的使用 dependencies 节点的使用 第二种方式不新建config.gradle 文件，使用跟目录下的build.gradle文件。 第三种方式使用配置文件 gradle.properties（通常 IDE 会自动生成此文件），在此文件中添加键值对：12rxjava=io.reactivex.rxjava2:rxjava:2.0.8rxandroid=io.reactivex.rxjava2:rxandroid:2.0.1 在 Module 的 build.gradle 中使用：1234dependencies &#123; compile rxjava compile rxandroid&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android TouchEvent事件传递机制]]></title>
      <url>%2F2016%2F03%2F31%2FAndroid%20TouchEvent%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Tounch相关的方法 方法名 方法作用 拥有类 dispatchTouchEvent() 分派event 调用下面2个方法，一般不重写 ViewGroup子类，非ViewGroup子类 onInterceptTouchEvent() 拦截event true 拦截 false 不拦截 ViewGroup子类 onTouchEvent() 处理event true 处理了 false 交给上级处理 ViewGroup子类，非ViewGroup子类 事件拦截是什么？要了解触摸事件的拦截机制，首先要知道什么是触摸事件？触摸事件顾名思义就是捕获接触屏幕后产生的事件，当操作应用时，会产生多个事件，按下按钮、这是Acition_Down事件，滑动、是Action_MOVE事件，手抬起、是Aciton_UP事件。这些事件你重新onTounchEvent（MotionEventeven）方法，可以从MotionEvent中找到参数。如此，看来触摸事件还是比较简单的，但是Android的View结构是树形结构，ViewGroup可以包含View，另一个ViewGroup，甚至可能继续嵌套，一层层的叠起来，我们的触摸事件就只有一个，分给谁？父ViewGroup和子View，子ViewGroup到底哪个处理，于是就产生了事件拦截。 事件拦截原理举一个通俗的例子，假设：你所在的公司有一个总裁，级别最高，下面是部门经理，级别次之，最底层，就是干活的我。 现在董事会交给一个任务给总裁。 总裁把这个任务安排给部长。 部长又把这个任务布置给我。 加班加点完成任务，交给部长。 部长感觉任务完成的不错，签名交给总裁。 总裁看了也感觉不错，汇报给董事会。这就是一个完整的事件传递流程。 总裁-MyViewGroupA，最外层的ViewGroup部长-MyViewGroupB，中间层的ViewGroup干活的我-MyView， 最底层的View 我们用一个实例来说明：在ViewGroup中我们重写dispatchTouchEvent(),onInterceptTouchEvent(),onTouchEvent()方法，在View我们重写dispatchTouchEvent()，onTouchEvent() 方法。这里可以看出ViewGroup的级别比较高，有onInterceptTouchEvent()这个事件拦截方法。 首先我们点击View，log打印如下：可以看出事件的传递顺序是：总裁（MyViewGroupA）-&gt; 部长（MyViewGroupB）-&gt; 我（MyView）事件传递先执行dispatchTouchEvent()方法，在执行onInterceptTouchEvent()方法。事件处理的顺序是：我（MyView）-&gt; 部长（MyViewGroupA）-&gt; 总裁（MyViewGroupA）事件处理都执行的是onTouchEvent()方法。 总裁觉得这个任务太简单自己就能搞定，在onInterceptTouchEvent()中返回true将事件拦截掉，log打印如下：和我们设想的一样，总裁一个人把事情干完了，下面的人就没事干了。 部长觉得总裁安排的任务太简单，没必麻烦我，log打印如下：这次我（MyView）就不用干活了。 你每天处理完任务想上司报告，那天你受不了压迫，不想干了，自己罢工，在onTouchEvent()返回True，log打印如下：事件传递还是跟以前一样，但是事件处理却在我（MyView）这里断掉了。 参考(http://blog.csdn.net/morgan_xww/article/details/9372285)(http://www.cnblogs.com/linjzong/p/4191891.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Paint 属性详解]]></title>
      <url>%2F2016%2F01%2F19%2FAndroid%20Paint%20%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Paint即画笔,在绘图过程中起到了极其重要的作用,画笔主要保存了颜色， 样式等绘制信息,指定了如何绘制文本和图形,画笔对象有很多设置方法， 大体上可以分为两类,一类与图形绘制相关,一类与文本绘制相关. 图形绘制 设置Paint的标志Paint.ANTI_ALIAS_FLAG 抗锯齿, Paint.FILTER_BITMAP_FLAG 位图过滤器,Paint.DITHER_FLAG 防抖动, Paint.UNDERLINE_TEXT_FLAG 启用下划线,Paint.STRIKE_THRU_TEXT_FLAG 启用中划线, Paint.FAKE_BOLD_TEXT_FLAG 加粗文本Paint.LINEAR_TEXT_FLAG 线性文本, Paint.SUBPIXEL_TEXT_FLAG 应用子像素抗锯齿效果Paint.DEV_KERN_TEXT_FLAG 使用设备的文本字距。 设置绘制的颜色 a代表透明度，r，g，b代表颜色值。setARGB(int a,int r,int g,int b); 设置a[0..255] 0：代表全透明 255代表不透明。setAlpha(int a); 设置绘制的颜色,使用颜色值来表示,该颜色值包括透明度和RGB颜色。setColor(int color) 设置是否使用抗锯齿功能,会消耗较大资源,绘制图形速度会变慢。setAntiAlias(boolean aa); 设置是否使用图像抖动处理,会使绘制出来的图片颜色更加平滑和饱满,图像更加清晰。setDither(boolean dither); 设置画笔的隐藏模式,INTING_OFF 或者 HINTING_ON。setHinting(int mode) 如果该项设置为true,则图像在动画进行中会滤掉对Bitmap图像 的优化操作,加快显示速度,本设置项依赖于dither和xfermode的设置setFilterBitmap(boolean filter); 设置MaskFilter,可以用不同的MaskFilter实现滤镜的效果,如滤化,立体等。setMaskFilter(MaskFilter maskfilter); 设置颜色过滤器,可以在绘制颜色时实现不用颜色的变换效果。setColorFilter(ColorFilter colorfilter); 设置绘制路径的效果,如点画线等。setPathEffect(PathEffect effect); 设置图像效果,使用Shader可以绘制出各种渐变效果。setShader(Shader shader); 在图形下面设置阴影层,产生阴影效果,radius为阴影的角度,dx和dy为阴影在x轴和y轴上的距离, color为阴影的颜色。setShadowLayer(float radius ,float dx,float dy,int color); 设置画笔的样式,为FILL 描边,FILL_OR_STROKE 描边并填充,或STROKE 填充。setStyle(Paint.Style style); 设置画笔的笔触风格，如圆形样式Cap.ROUND,或方形样式Cap.SQUARE,默认是Paint.Cap.BUTT,也是方形样式。setStrokeCap(Paint.Cap cap); 设置接合处的形态，如Join.MITER 锐角,Join.ROUND 圆弧,Join.BEVEL 直线。setStrokeJoin(Paint.Join join); 设置笔画的倾斜度,取值：&gt;=0,设置笔触的连接处的样式,可以和setStrokeJoin()来比较。setStrokeMiter(float miter ) 设置画笔的粗细度。setStrokeWidth(float width); 文本绘制 模拟实现粗体文字，设置在小字体上效果会非常差。‘setXfermode(Xfermode xfermode);’ 设置该项为true，将有助于文本在LCD屏幕上的显示效果。setSubpixelText(boolean subpixelText); 设置绘制文字的对齐方向。setTextAlign(Paint.Align align); 设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果 。setTextScaleX(float scaleX); 设置绘制文字的字号大小,设置值必须大于0。setTextSize(float textSize); 设置斜体文字，skewX为倾斜弧度,值为右负左正,官方推崇的值为-0.25。setTextSkewX(float skewX); 设置Typeface对象,即字体风格,包括粗体,斜体以及衬线体,非衬线体等。setTypeface(Typeface typeface); 设置带有下划线的文字效果。setUnderlineText(boolean underlineText); 设置带有删除线的效果。setStrikeThruText(boolean strikeThruText); 设置是否打开线性文本标识。setLinearText (boolean linearText) 设置地理位置,直接传入Locale.getDefault()。setTextLocale (Locale locale) 设置字体的样式,样式可以为null。setFontFeatureSettings(String settings)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Service 详解]]></title>
      <url>%2F2015%2F12%2F12%2FAndroid%20Service%20%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Service 简介Service作为Android四大组件之一，在每一个应用程序中都扮演着非常重要的角色。它主要用于在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。必要的时候我们甚至可以在程序退出的情况下，让Service在后台继续保持运行状态。 Service 生命周期图 onStartCommand()当使用StartService()启动服务时,系统会调用此方法,一旦执行此方法,服务将会启动,并在后台无限运行,如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务. onBind()当使用BindService()启动服务时，系统会调用此方法，在此方法中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信，如果你不希望绑定，则应该返回null。 onCreate()首次创建服务时，系统会调用此方法来执行初始化操作（在调用 onStartCommand() 或 onBind() 之前)，如果服务已经运行,则不会调用此方法。 onDestroy()当服务不再使用且被销毁时，系统调用此方法，服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 左图：是使用startService启动的服务生命周期，它启动的服务绘制后台运行，与Activity没有关联。 右图：是使用bindService启动的服务生命周期，它启动的服务会和Activity绑定，Activity销毁Service也会随之销毁。 前台 Service前台服务与后台服务相比：它有一个一直在运行的图标在系统的状态栏显示，下拉菜单栏后可以看到更清楚的信息，非常类似通知效果。123456789101112131415//前台服务Intent intent = new Intent(this, MainActivity.class);PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);Notification notification = new Notification.Builder(this) .setContentTitle(&quot;前台服务标题&quot;) .setContentText(&quot;前台服务内容&quot;) .setWhen(System.currentTimeMillis()) //系统时间 .setSmallIcon(R.drawable.ic_stat_name) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .build();//绑定服务startForeground(1, notification);//关闭前台服务stopForeground(false); 远程Service（AIDL） 创建AIDL接口 12345678interface IRemoteService &#123; //求和 int add(int a, int b); //转化 String toUpperCase(String str); //保存 Person save(in Person person);&#125; 这里我传递对象所以必须定义与Person同名的AIDL文件，代码如下： 12package com.jkwar.serviceExample;parcelable Person; 实现接口实现 Service 并重写 onBind() 以返回 Stub 类的实现。 123456789101112131415161718192021222324private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; @Override public int add(int a, int b) throws RemoteException &#123; Log.d(TAG, &quot;add: executed&quot;); return a + b; &#125; @Override public String toUpperCase(String str) throws RemoteException &#123; Log.d(TAG, &quot;toUpperCase: executed&quot;); return str.toUpperCase(); &#125; @Override public Person save(Person person) throws RemoteException &#123; Log.d(TAG, &quot;save: executed&quot;); if (person == null) &#123; return new Person(2, &quot;hello word&quot;); &#125; Log.d(TAG, &quot;Name: &quot; + person.getName()); Log.d(TAG, &quot;Id: &quot; + person.getId()); return person; &#125;&#125;; 并在AndroidManifest.xml文件中绑定action 123456789&lt;service android:name=&quot;.RemoteService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:process=&quot;:remote&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.jkwar.serviceExample.IRemoteService&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; process有2种赋值：“:remote” 和 “remote”带有”:”的表示该服务所在的进程是私有的，即只要有客户端去启动该服务，系统就会创建一个新的进程来运行该服务。不带有”:”的表示该服务所在的进程是共享的，即当前系统不管有几个客户端去启动该服务，系统中只有一个进程来运行该服务。 新建名为client的Module，实现Service通讯。 使用bindService启动服务。 12345678910111213private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; iRemoteService = IRemoteService.Stub.asInterface(service); Log.d(TAG, &quot;onServiceConnected: &quot;); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, &quot;onServiceDisconnected: &quot;); iRemoteService = null; &#125;&#125;; 由于Android 5.0不支持隐式Intent。 123456789//第一种方式Intent intent = new Intent(IRemoteService.class.getName());intent.setClassName(&quot;com.jkwar.serviceExample&quot;, &quot;com.jkwar.serviceExample.RemoteService&quot;);//将隐式启动转换为显示启动Intent mIntent = new Intent();mIntent.setAction(&quot;com.jkwar.serviceExample.IRemoteService&quot;);Intent eintent = new Intent(getExplicitIntent(this,mIntent));//绑定服务bindService(eintent, connection, BIND_AUTO_CREATE); 源码下载ServiceExample 参考Android Service完全解析，关于服务你所需知道的一切官方Api]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity Task 相关]]></title>
      <url>%2F2015%2F11%2F29%2FActivity%20Task%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[Android 任务栈简介 在Android 系统中，通过栈结构来保存整个APP的Activity，栈的结构是先进先出（Last In First Out）的线性表，当一个Activity启动另外一个Activity的时候，新启动的Activity就会置于任务栈的顶端，并处于活动状态,而启动它的Activity依然保持在任务栈中，处于停止状态，当用户按下返回键或者调用Finish方法时，系统会移除顶部的Activity，让后面的Activity回复活动状态。当然，这里也有特权阶级，就是在AndroidManinifest文件中的属性android：launchMode来设置或者通过Intent的flag来设置。 AndroidMainifest启动模式 Android 的启动模式一个有四种，分别是standard、singleTop、singleTask、singleStance，具有不同的功能。 standard默认启动模式，每次激活Activity都会创建新的实例，并放入任务栈中。使用场景：大多数的Activity。 singleTop如果在任务的栈顶正好存在该Activity的实例，就重用该实例(会调用实例的onNewIntent())，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景：接受消息后显示的界面（新闻类和阅读类App的内容界面）。 singleTask如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景：浏览器的主界面或者退出整个应用。浏览器的主界面：不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。退出整个应用：将主Activity设为SingleTask模式，然后在要退出的Activity中转到主Activity，从而将主Activity之上的Activity都清除，然后重写主Activity的onNewIntent方法，在方法中加上一句finish(),将最后一个Activity结束掉。 singleStance在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景：如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。 注意：如果在一个singleTask和singleStance的ActivityA中通过startActivityResult()方法启动另外一个ActivityB，那么系统会直接方法Activity.RESULT_CANCELED而不会再去等待方法。这是游戏系统在Framework层做了限制，所以二种不同Task之间，默认是不能传递数据的，如果一定要传递，那就只能通过Intent来绑定数据。 Intent Flag 启动模式 Intent.FLAG_ACTIVITY_NEW_TASK（默认） 使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task，该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。 Intent.FLAG_ACTIVITY_SINGLE_TOP 使用singletop模式来启动一个Activity，与指定android：launchMode=”singleTop“效果相同。 Intent.FLAG_ACTIVITY_CLEAR_TOP 如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的I ntent投递到老的Activity（现在位于顶端）中。例如：假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。 Intent.FLAG_ACTIVITY_NO_HISTORY 如果设置，这将在Task的Activitystack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED在重置Task或者启动Activity创建新的Task时生效。 Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 使用这种模式启动Activity，重置该Task时清除该Activity。例如：A以这种模式启动B，B又启动C，当用户离开应用，一段时间后又从Home回到应用，显示A界面，当前Activity栈为A。 Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。例如：假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 如果设置，新的Activity不会在最近启动的Activity的列表中保存。 Intent.FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。 清空任务栈 系统提供清空任务栈的方法让我让我们将一个Task清除。通常情况下，我们在AndroidMainifest文件中的标签中使用以下几种属性来清理任务栈。 clearTaskOnLaunch 每次返回该Activity时，都将该Activity之上的所有Activity清除，通过这个属性，可以让这个Task每次在初始化的时候，都只 有这个Activity。 finishOnTaskLaunch finishOnTaskLaunch属性与clearTaskOnLaunch类似，只不过finishOnTaskLaunch是作业在自己身上，通过这个属性，当离开这个Activity所在的Task，那么用户返回时，该Activity就会被finish掉。 alwaysRetainTaskState alwayRetainTaskState属性给Task设置免死金牌，如果如果将Activity的这个属性设置为True，那么该Activity所在的Task将不接受任何清理命令，一直保持当前Task状态。 allowTaskReparenting Activity实例在当前应用退居后台后，是否能从启动它的那个task移动到有共同affinity的task，“true”表示可以移动，“false”表示它必须呆在当前应用的task中，默认值为false。 参考(http://blog.csdn.net/liuhe688/article/details/6761337)(https://my.oschina.net/u/2336511/blog/392412)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity 生命周期]]></title>
      <url>%2F2015%2F10%2F10%2FActvitiy%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Activity 生命周期是什么？ Activity生命周期是为了更好的管理Activty的一套规则，它可以在多种形态之间进行切换，以此来适应不同的要求。 Activity 形态 Activity/Running该状态下，Activity处于Activity栈的最顶层，可见，并可以与用户进行交互。 Paused该状态下，Activity失去焦点，被另外一个非全屏或者通明的Activity所遮盖，Activity就会进入Paused形态，但是它只是失去与用户交互的能力，所有的状态信息，成员变量都还保持着，只有在系统内存极低的情况下，才会被系统回收掉。 Stopped该状态下，Activity被另外一个Activity完全覆盖，Activity就会进入Stopped形态，此时它不再可见，但是所有的状态信息，成员变量都还保存着。 Killed当Activity被系统回收掉或者Activity从来没有创建过，那么Activity就会处于Killed状态。 由此可见，用户的不同动作，会让Activity在这四种形态将切换，而开发者，虽然可以控制Activity如何生，却无法控制Activity如何死。 生命周期图 谷歌给我们一张图来揭示Activity的生命周期，它希望Activity的生命周期能被开发者所控制，而不是一匹脱缰的野马。 开发者不必实现所有的生命周期方法，但是我们必须知道每个生命周期状态的含义，可以让我们更好的掌控Activity，让它能更好的完成你所期待的效果。虽然有很多的Activity的生命周期状态，但是其中只有三种状态是稳定的，而其他状态都是过渡状态，很快就会结束。 Running该状态下，Activity处于Activity栈顶，用户可以与它交互。 Paused当Activity被遮盖时进入这个状态，此时，它不再接受用户输入。 Stopped当Activity完全被覆盖是进入这个状态，此时它不可见，仅在后台运行。 启动与销毁Activity的过程 在系统调用onCreate()之后,就马上调用onStart(),之后再调用onResume()，最后停留在Resumed状态，完成启动。系统调用onDestroy()销毁Activity生命周期让它回到Killed形态。 以上过程就是Activity的启动与销毁过程。 onCreate()：声明UI元素，定义成员变量，配置UI等（onCreate里面尽量少做事情，避免程序启动太久都看不到界面）。 onDestory()：因为引用会在Activity销毁的时候销毁，而线程不会，如果activity含有在onCreate调用时创建的后台线程，或者是其他有可能导致内存泄漏的资源，则应该在OnDestroy()时进行资源清理，杀死后台线程。 暂停与恢复Activity的过程 当Activity被其他组件阻塞时部分不可见，就会导致当前Activity进入Pause状态，此时系统就会调用activity中的onPause()方法。当阻塞结束后，就会调用onResume()方法恢复到Resumed状态。 以上过程就是Activity的暂停与恢复过程。 onPause()：释放系统资源（如broadcast receivers, sensors，Camera等）、停止动画或者是其他正在运行的操作。 onResume()：重新初始化那些在 onPause()中释放的资源，并执行一些停止的操作（如开启动画）。 停止与重启Activity的过程 当Activity部分不可见时，有2种可能，从部分不可见到可见，系统调用onResume()恢复到Resumed状态；从部分不可见到完全不可见，系统调用onStop()停止Activity进入Stopped状态，注意无论什么原因导致Activity停止，系统总是会在onStop()之前调用onPause()方法。当activity从Stopped状态回到前台时，系统调用onRestart()，马上调用onStart()，之后再执行onResume()。 以上过程就是Activity停止和重启启动过程。 onStop()：释放系统资源（在极端情况下，系统会直接杀死我们的app进程，并不执行activity的onDestroy()回调方法，所以要在这些释放系统资源，避免内存泄漏）、执行那些CPU intensive的shut-down操作，例如往数据库写信息。 onStart()：重新初始化那些在 onStop()中释放的资源。 重新创建Activity 如果系统长时间处于stopped形态而且此时系统需要更多内存或者系统内存极为紧张时，系统会回收你的Activity，而此时系统会将Actvity状态通过onSaveInstanceState() 方法保存到Bundle对象中，当然我们可以通过增加额外的键值对的集合来保存状态信息，比如在 EditText 组件中的文本或 ListView的滑动位置。当我们需要重新创建Activity的时候，保存的Bundle对象会传递到Activity的onRestoreInstanceState() 方法和onCreate()方法中。 由于 onCreate() 方法会在第一次创建新的Activity实例与重新创建之前被Destory的实例时都被调用，我们必须在尝试读取 Bundle 对象前检测它是否为null。如果它为null，系统则是创建一个新的Activity实例，而不是恢复之前被Destory的Activity。 onRestoreInstanceState()方法会在 onStart() 方法之后执行. 系统仅仅会在存在需要恢复的状态信息时才会调用 onRestoreInstanceState() ，因此不需要检查 Bundle 是否为null。 横竖屏切换时Android 生命周期 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。 设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。 设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 参考Android 群英传Android官方培训Activity Api]]></content>
    </entry>

    
  
  
</search>
